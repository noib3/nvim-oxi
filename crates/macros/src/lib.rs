use proc_macro::TokenStream;
use syn::parse_macro_input;

mod derive_opts;

#[cfg(feature = "plugin")]
mod plugin;

#[cfg(feature = "test")]
mod test;

/// TODO: docs
#[proc_macro_derive(OptsBuilder, attributes(builder))]
pub fn derive_opts_builder(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as syn::DeriveInput);
    derive_opts::expand_derive_opts_builder(&input)
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/// Marks the function as the entrypoint of the plugin.
///
/// The function wrapped by this macro will be called by Neovim when the user
/// loads the plugin by passing its name to the `require` function. It can
/// return any type that implements the [`Pushable`] trait, and the value will
/// be returned on the Lua side by `require`.
///
/// # Examples
///
/// Let's say your crate only consists of this single `lib.rs` file:
///
/// ```ignore
/// // lib.rs
///
/// #[nvim_oxi::plugin]
/// fn my_plugin() -> u32 {
///     42
/// }
/// ```
///
/// Once the crate is compiled and the resulting dynamic library is placed
/// under `lua/my_plugin.{so|dylib|dll}` somewhere in Neovim's [`runtimepath`],
/// it can be loaded with:
///
/// ```lua
/// local ret = require("my_plugin")
/// assert(ret == 42)
/// ```
///
/// [`Pushable`]: https://docs.rs/nvim-oxi/latest/nvim_oxi/lua/trait.Pushable.html
/// [`runtimepath`]: https://neovim.io/doc/user/options.html#'runtimepath'
///
/// # Specify the path to `nvim-oxi`
///
/// The code generated by this macro includes calls to functions defined in the
/// `nvim-oxi` crate, which is expected to be in scope under `::nvim_oxi`. This
/// can cause problems if you renamed the crate in your `Cargo.toml` or if it's
/// re-exported from another crate.
///
/// In these cases, you can use the `nvim_oxi` attribute to specify the path to
/// `nvim-oxi`.
///
/// For example, let's say your crate has a single dependency called `foo`
/// whose whose `lib.rs` re-exports `nvim-oxi` as `nvim`:
///
/// ```ignore
/// // foo's lib.rs
/// pub use nvim_oxi as nvim;
/// ```
///
/// Doing this would generate a compilation error because `nvim_oxi` is not in
/// scope:
///
/// ```compile_fail
/// #[foo::nvim::plugin]
/// fn my_plugin() {}
/// ```
///
/// To fix this, you can use the `nvim_oxi` attribute to specify the correct
/// path:
///
/// ```ignore
/// #[foo::nvim::plugin(nvim_oxi = foo::nvim)]
/// fn my_plugin() {}
/// ```
#[cfg(feature = "plugin")]
#[proc_macro_attribute]
pub fn plugin(attr: TokenStream, item: TokenStream) -> TokenStream {
    plugin::plugin(attr, item)
}

/// Tests a piece of code inside a Neovim session.
///
/// # Examples
///
/// ```ignore
/// use nvim_oxi::{self as nvim, api};
///
/// #[nvim::test]
/// fn set_get_del_var() {
///     api::set_var("foo", 42).unwrap();
///     assert_eq!(Ok(42), api::get_var("foo"));
///     assert_eq!(Ok(()), api::del_var("foo"));
/// }
/// ```
#[cfg(feature = "test")]
#[proc_macro_attribute]
pub fn test(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let item = parse_macro_input!(item as syn::ItemFn);
    test::test(item).into()
}
